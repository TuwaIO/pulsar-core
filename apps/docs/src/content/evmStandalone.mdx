# Using EVM Trackers Standalone

While the Pulsar suite provides a comprehensive solution with a UI (`@tuwaio/nova-transactions`) and a Zustand-based state store (`@tuwaio/pulsar-core`), its architecture is modular. This means you can use the low-level **trackers** (`evmTracker`, `gelatoFetcher`, `safeFetcher`) from `@tuwaio/pulsar-evm` directly, without installing or configuring the core state management store.

This is incredibly useful if:

-   You already have your own state management solution (Redux, MobX, Valtio, etc.) and want to integrate only the tracking logic.
-   You need tracking logic on the server-side, where a client-side store is unnecessary.
-   You want maximum, granular control over every stage of the transaction lifecycle.

---

## Why Use `evmTracker`?

One might ask, "Why do I need `evmTracker` if I can just use `waitForTransactionReceipt` from `viem`?"

While `waitForTransactionReceipt` is an excellent function, it only solves part of the problem. `evmTracker` provides a more robust and complete solution out-of-the-box.

| Feature                | `waitForTransactionReceipt` (viem)                                                                                                      | `evmTracker` (Pulsar)                                                                                                                                                                |
| :--------------------- | :-------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Handles RPC Lags** | ❌ No. If called immediately after submission, the RPC node might not see the transaction yet, causing a "transaction not found" error. | ✅ **Yes.** Includes a built-in retry mechanism to wait for the transaction to appear in the mempool.                                                                                |
| **Full Lifecycle** | 🤷‍♂️ Limited. Mainly reacts to transaction completion or replacement.                                                                     | ✅ **Yes.** Provides callbacks for every stage: `onInitialize` (start), `onTxDetailsFetched` (details received), `onSuccess` (mined), `onReplaced` (replacement), `onFailure` (error). |
| **Fetches Tx Details** | ❌ No. Does not return full transaction details like `nonce`, `value`, etc.                                                             | ✅ **Yes.** Internally calls `getTransaction` and passes the full transaction data to the callbacks.                                                                                 |
| **Abstraction Level** | Low. Requires the developer to orchestrate the tracking logic themselves.                                                               | High. Encapsulates the entire tracking process into one convenient async function.                                                                                                   |

Simply put, `evmTracker` is a reliable wrapper around `viem`'s functions that solves common edge cases and significantly simplifies your code.

---

## Trackers Overview

### 1. EVM Tracker

This is the primary tracker for monitoring standard on-chain transactions in EVM networks. It operates using a transaction hash.

#### How It Works

`evmTracker` first tries to fetch transaction details using `getTransaction`. If the RPC node hasn't indexed the transaction yet, it will retry several times. Once the details are fetched, it begins waiting for the receipt using `waitForTransactionReceipt`.

#### Example Usage

```tsx
import { evmTracker } from '@tuwaio/pulsar-evm';
import { mainnet } from 'viem/chains';

async function trackMyTransaction(txHash) {
  console.log(`Starting to track transaction: ${txHash}`);

  await evmTracker({
    // `chains` array is needed to create a viem client internally
    chains: [mainnet],
    tx: {
      txKey: txHash, // The transaction hash
      chainId: 1,    // The network ID
    },

    // Callback when transaction details are successfully fetched
    onTxDetailsFetched: (txDetails) => {
      console.log('Transaction details received:', txDetails);
      // Here you can update your state to show nonce, gas, etc.
    },

    // Callback when the transaction is successfully mined (even if reverted)
    onSuccess: (txDetails, receipt) => {
      console.log('Transaction mined!', receipt);
      if (receipt.status === 'success') {
        // Update your state to 'Success'
      } else {
        // Update your state to 'Failed'
      }
    },

    // Callback if the transaction was replaced (sped up/cancelled)
    onReplaced: (replacement) => {
      console.log('Transaction was replaced:', replacement);
      // Update your state to 'Replaced'
    },

    // Callback on any error during the tracking process
    onFailure: (error) => {
      console.error('Tracking failed:', error);
      // Update your state to 'Failed'
    },
  });
}
````

### 2\. Gelato & Safe Fetchers

For polling-based trackers like **Gelato** and **Safe**, we export the `fetcher` functions directly. You can use these with Pulsar's `initializePollingTracker` or your own custom polling logic.

#### How They Work

The `gelatoFetcher` and `safeFetcher` are designed to be used with `@tuwaio/pulsar-core`'s `initializePollingTracker`. They contain the logic to query the respective APIs and call the correct callbacks (`onSuccess`, `onFailure`, etc.) when a transaction reaches a terminal state.

#### Example Usage with `initializePollingTracker`

```tsx
import { initializePollingTracker } from '@tuwaio/pulsar-core';
import { gelatoFetcher, safeFetcher } from '@tuwaio/pulsar-evm';

// Example for Gelato
async function trackGelatoTask(taskId) {
  await initializePollingTracker({
    tx: { txKey: taskId },
    fetcher: gelatoFetcher,
    onSuccess: (gelatoStatus) => {
      console.log('Gelato task succeeded!', gelatoStatus);
    },
    onFailure: (gelatoStatus) => {
      console.error('Gelato task failed.', gelatoStatus);
    },
  });
}

// Example for Safe
async function trackSafeTx(safeTxHash, chainId, fromAddress) {
  await initializePollingTracker({
    tx: { txKey: safeTxHash, chainId, from: fromAddress },
    fetcher: safeFetcher,
    onSuccess: (safeStatus) => {
      console.log('Safe transaction succeeded!', safeStatus);
    },
    onFailure: (safeStatus) => {
      console.error('Safe transaction failed.', safeStatus);
    },
    onReplaced: (replacement) => {
      console.warn('Safe tx was replaced!', replacement);
    }
  });
}
```

-----

## Helper Functions

The `@tuwaio/pulsar-evm` package also exports several utilities that are useful even without the full Pulsar store.

### `checkTransactionsTracker`

A key routing function. After you submit a transaction, you get back a key. This function helps you determine which tracker to use for that key.

```tsx
import { checkTransactionsTracker, TransactionTracker } from '@tuwaio/pulsar-evm';

// Example 1: Regular hash
const { tracker, txKey } = checkTransactionsTracker('0x...', 'injected');
// tracker -> 'ethereum', txKey -> '0x...'

// Example 2: Key from Gelato
const { tracker, txKey } = checkTransactionsTracker({ taskId: '0x123...' }, 'injected');
// tracker -> 'gelato', txKey -> '0x123...'

// Example 3: Hash from Safe
const { tracker, txKey } = checkTransactionsTracker('0xabc...', 'safe');
// tracker -> 'safe', txKey -> '0xabc...'
```

### `checkChainForTx`

A utility that checks if the user is on the correct network and prompts them to switch using your `wagmi` config.

```tsx
import { checkChainForTx } from '@tuwaio/pulsar-evm';
import { wagmiConfig } from './config'; // Your wagmi config

async function safeSendTransaction(targetChainId) {
  try {
    await checkChainForTx(targetChainId, wagmiConfig);
    console.log('Network is correct, sending transaction...');
    // ...your transaction sending logic...
  } catch (error) {
    console.error(error.message); // e.g., "User rejected the request to switch network."
  }
}
```